---
description: Rust 后端开发规则
globs: ["src-tauri/src/**/*.rs"]
---

# Rust 后端开发规则

## 模块职责

| 文件 | 职责 |
|------|------|
| `commands.rs` | Tauri IPC 命令定义 |
| `adb.rs` | ADB 通信、设备管理、进程缓存 |
| `parser.rs` | logcat 日志行解析 |
| `filter.rs` | 过滤逻辑（可选后端过滤）|

## IPC 命令定义

```rust
#[tauri::command]
pub async fn command_name(
    app: AppHandle,           // 可选，用于发送事件
    param: String,            // 参数
    state: State<'_, MyState>, // 可选，访问状态
) -> Result<ReturnType, String> {
    // 实现
    Ok(result)
}
```

在 `main.rs` 注册：

```rust
.invoke_handler(tauri::generate_handler![
    command_name,
    // ...
])
```

## 发送事件到前端

```rust
use tauri::Emitter;

// 发送日志批次
app_handle.emit("logcat-entries", &log_batch)?;
```

## 错误处理

```rust
// ✅ 使用 Result 和 ? 操作符
fn process() -> Result<T, String> {
    let value = fallible_op().map_err(|e| e.to_string())?;
    Ok(value)
}

// ❌ 避免 unwrap() 在生产代码
let value = option.unwrap();  // 不推荐
```

## 日志记录

```rust
use log::{info, error, debug};

info!("Starting logcat for device: {}", device_id);
error!("Failed to parse log: {}", line);
```

## ADB 命令执行

```rust
use tokio::process::Command;

let output = Command::new("adb")
    .args(["-s", device_id, "logcat", "-v", "threadtime"])
    .output()
    .await?;
```

## 状态管理

```rust
pub struct LogcatState {
    pub process: Arc<Mutex<Option<Child>>>,
    pub is_running: Arc<Mutex<bool>>,
}

// 访问状态
let mut is_running = state.is_running.lock().await;
*is_running = true;
```

## 性能注意

- 日志批量发送（每 50 条或 100ms）
- 使用 channel 异步处理
- 进程名缓存避免重复查询
